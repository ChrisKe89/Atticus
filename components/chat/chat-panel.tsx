"use client";

/**
 * Autogenerated documentation for `components/chat/chat-panel.tsx` within the Atticus codebase.
 * Key exports: follow the named or default exports defined below; inputs and outputs remain as implemented and correlate with related modules via existing imports.
 * Documentation only—do not modify runtime behavior when updating this comment.
 */

import { useEffect, useRef, useState } from "react";
import { Loader2, Send } from "lucide-react";
import { streamAsk, type AskStreamEvent } from "@/lib/ask-client";
import type { AskResponse, AskSource } from "@/lib/ask-contract";
import AnswerRenderer from "@/components/AnswerRenderer";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";

interface ChatMessage {
  id: string;
  role: "user" | "assistant";
  content: string;
  status?: "pending" | "complete" | "error";
  response?: AskResponse;
  error?: string;
  question?: string;
}

function createId() {
  return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
}

function formatConfidence(confidence: number | null | undefined) {
  if (confidence === null || confidence === undefined || Number.isNaN(confidence)) {
    return "—";
  }
  return `${Math.round(confidence * 100)}%`;
}

export function ChatPanel() {
  const FRIENDLY_VALIDATION_MSG =
    "There is no context to that question or it is not a proper question, please try again";
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [composer, setComposer] = useState("");
  const [isStreaming, setIsStreaming] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showIntro, setShowIntro] = useState(true);
  const formRef = useRef<HTMLFormElement | null>(null);
  const textareaRef = useRef<HTMLTextAreaElement | null>(null);

  const autoResize = () => {
    const el = textareaRef.current;
    if (!el) return;
    // Base: 3 rows; allow growth up to 6 rows, then scroll
    const maxRows = 6;
    const style = window.getComputedStyle(el);
    const lineHeight = parseFloat(style.lineHeight || "20");
    const padding = parseFloat(style.paddingTop || "0") + parseFloat(style.paddingBottom || "0");
    const border = parseFloat(style.borderTopWidth || "0") + parseFloat(style.borderBottomWidth || "0");
    const minHeight = Math.max(0, lineHeight * 3 + padding + border);
    const maxHeight = Math.max(minHeight, lineHeight * maxRows + padding + border);
    el.style.height = "auto";
    const newHeight = Math.min(el.scrollHeight, Math.floor(maxHeight));
    el.style.height = `${newHeight}px`;
    el.style.overflowY = el.scrollHeight > maxHeight ? "auto" : "hidden";
  };

  useEffect(() => {
    autoResize();
  }, [composer]);

  async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault();
    const trimmed = composer.trim();
    if (!trimmed || isStreaming) {
      return;
    }
    setError(null);
    if (showIntro) {
      setShowIntro(false);
    }

    const userMessage: ChatMessage = {
      id: createId(),
      role: "user",
      status: "complete",
      content: trimmed,
    };
    const placeholder: ChatMessage = {
      id: createId(),
      role: "assistant",
      status: "pending",
      content: "Atticus is thinking...",
      question: trimmed,
    };

    setMessages((prev) => [...prev, userMessage, placeholder]);
    setComposer("");
    setIsStreaming(true);

    try {
      await streamAsk(
        { question: trimmed, filters: undefined, contextHints: undefined, topK: undefined, models: undefined },
        {
          onEvent: (event: AskStreamEvent) => {
            if (event.type === "answer") {
              const response = event.payload;
              setMessages((prev) =>
                prev.map((message) =>
                  message.id === placeholder.id
                    ? {
                        ...message,
                        status: "complete",
                        content: response.answer ?? response.clarification?.message ?? "",
                        response,
                      }
                    : message
                )
              );
            }
            if (event.type === "end") {
              setIsStreaming(false);
            }
          },
        }
      );
    } catch (err) {
      setIsStreaming(false);
      const messageError = err instanceof Error ? err.message : FRIENDLY_VALIDATION_MSG;
      // Only show bottom error if it's not the friendly validation message
      setError(messageError === FRIENDLY_VALIDATION_MSG ? null : messageError);
      setMessages((prev) =>
        prev.map((message) =>
          message.id === placeholder.id
            ? {
                ...message,
                status: "error",
                content: FRIENDLY_VALIDATION_MSG,
                error: messageError,
              }
            : message
        )
      );
    }
  }

  async function handleClarificationChoice(messageId: string, models: string[]) {
    if (!models.length || isStreaming) {
      return;
    }
    const target = messages.find((message) => message.id === messageId);
    if (!target?.question) {
      return;
    }
    setError(null);
    if (showIntro) {
      setShowIntro(false);
    }
    setIsStreaming(true);
    setMessages((prev) =>
      prev.map((message) =>
        message.id === messageId
          ? {
              ...message,
              status: "pending",
              content: "Atticus is thinking...",
              response: message.response ? { ...message.response, clarification: undefined } : message.response,
            }
          : message
      )
    );

    try {
      await streamAsk(
        {
          question: target.question,
          models,
          filters: undefined,
          contextHints: undefined,
          topK: undefined,
        },
        {
          onEvent: (event: AskStreamEvent) => {
            if (event.type === "answer") {
              const response = event.payload;
              setMessages((prev) =>
                prev.map((message) =>
                  message.id === messageId
                    ? {
                        ...message,
                        status: "complete",
                        content: response.answer ?? response.clarification?.message ?? "",
                        response,
                      }
                    : message
                )
              );
            }
            if (event.type === "end") {
              setIsStreaming(false);
            }
          },
        }
      );
    } catch (err) {
      const messageError = err instanceof Error ? err.message : FRIENDLY_VALIDATION_MSG;
      // Only show bottom error if it's not the friendly validation message
      setError(messageError === FRIENDLY_VALIDATION_MSG ? null : messageError);
      setMessages((prev) =>
        prev.map((message) =>
          message.id === messageId
            ? {
                ...message,
                status: "error",
                content: FRIENDLY_VALIDATION_MSG,
                error: messageError,
              }
            : message
        )
      );
    } finally {
      setIsStreaming(false);
    }
  }

  return (
    <section className="flex h-full min-h-0 flex-1 flex-col">
      <div className="flex-1 min-h-0 overflow-y-auto px-4 pb-6 pt-6 sm:px-6 lg:px-8 [-ms-overflow-style:none] [scrollbar-width:none] [&::-webkit-scrollbar]:hidden">
        {showIntro && messages.length === 0 ? (
          <div className="flex h-full min-h-full items-center justify-center text-center">
            <div className="max-w-xl space-y-3">
              <p className="text-sm font-semibold uppercase tracking-[0.35em] text-slate-400 dark:text-slate-500">
                Welcome
              </p>
              <h2 className="text-2xl font-semibold text-slate-900 dark:text-slate-100">
                Hi there — I’m Atticus.
              </h2>
              <p className="text-base text-slate-600 dark:text-slate-300">
                Ask me about any FUJIFILM product, process, or spec. Every answer comes sourced
                from verified documentation.
              </p>
            </div>
          </div>
        ) : (
          <div className="flex min-h-full flex-col justify-end gap-4">
            {messages.map((message) => (
              <article
                key={message.id}
                className={
                  message.role === "assistant" ? "flex justify-start" : "flex justify-end"
                }
              >
                <div
                  className={
                    message.role === "assistant"
                      ? "max-w-3xl rounded-2xl bg-slate-100 p-4 text-sm text-slate-800 shadow dark:bg-slate-900 dark:text-slate-200"
                      : "max-w-3xl rounded-2xl bg-slate-900 p-4 text-sm text-white shadow dark:bg-slate-100 dark:text-slate-900"
                  }
                >
                  {message.role === "assistant" ? (
                    <AnswerRenderer
                      text={message.content}
                      response={message.response}
                      disabled={isStreaming}
                      onClarify={(models) => handleClarificationChoice(message.id, models)}
                    />
                  ) : (
                    <p className="whitespace-pre-wrap">{message.content}</p>
                  )}
                  {message.response?.sources?.length ? (
                    <div className="mt-3 space-y-1 text-xs text-slate-600 dark:text-slate-400">
                      <p className="font-semibold uppercase tracking-wide">Sources</p>
                      <ul className="space-y-1">
                        {message.response.sources.map((source: AskSource, index) => (
                          <li key={`${message.id}-source-${index}`}>
                            {source.path}
                            {typeof source.page === "number" ? ` · page ${source.page}` : ""}
                            {source.heading ? ` · ${source.heading}` : ""}
                          </li>
                        ))}
                      </ul>
                    </div>
                  ) : null}
                  {message.response ? (
                    <footer className="mt-3 flex flex-wrap gap-3 text-xs text-slate-500 dark:text-slate-400">
                      <span>Confidence: {formatConfidence(message.response.confidence)}</span>
                      <span>
                        Escalate:{" "}
                        {message.response.should_escalate === undefined
                          ? "-"
                          : message.response.should_escalate
                          ? "Yes"
                          : "No"}
                      </span>
                      <span className="truncate">Request ID: {message.response.request_id}</span>
                    </footer>
                  ) : null}
                  {/* Suppress duplicate red error text inside bubbles; message content carries user-facing message */}
                </div>
              </article>
            ))}
          </div>
        )}
      </div>
      <div className="shrink-0 px-4 pb-4 pt-4 sm:px-6 lg:px-8">
        <form
          ref={formRef}
          onSubmit={handleSubmit}
          className="flex gap-3 rounded-2xl border border-slate-200 bg-white/95 p-4 shadow-lg backdrop-blur supports-[backdrop-filter]:backdrop-blur dark:border-slate-800 dark:bg-slate-950/90"
        >
          <div className="min-w-0 flex-1">
            <label htmlFor="chat-message" className="sr-only">
              Message Atticus
            </label>
            <Textarea
              id="chat-message"
              value={composer}
              onChange={(event) => setComposer(event.target.value)}
              ref={textareaRef}
              onKeyDown={(event) => {
                // Enter: send. Shift+Enter: newline
                const composing = (event.nativeEvent as unknown as { isComposing?: boolean }).isComposing;
                if (event.key === "Enter" && !event.shiftKey && !composing) {
                  event.preventDefault();
                  // Only submit if there is content and not streaming
                  if (!isStreaming && composer.trim()) {
                    // Prefer requestSubmit for proper form submission semantics
                    formRef.current?.requestSubmit();
                  }
                }
              }}
              rows={3}
              placeholder="Message Atticus..."
              className="min-h-[72px] resize-none overflow-y-hidden"
            />
          </div>
          <Button type="submit" disabled={isStreaming || !composer.trim()} className="self-end rounded-xl">
            {isStreaming ? (
              <Loader2 className="h-4 w-4 animate-spin" aria-hidden="true" />
            ) : (
              <Send className="h-4 w-4" aria-hidden="true" />
            )}
            <span>{isStreaming ? "Sending..." : "Send"}</span>
          </Button>
        </form>
        {error ? (
          <p className="mt-3 text-sm text-rose-600" role="status">
            {error}
          </p>
        ) : null}
      </div>
    </section>
  );
}
