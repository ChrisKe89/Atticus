"""Autogenerated documentation for `atticus/notify/mailer.py` within the Atticus project.

This module participates in the documentation pipeline by summarizing the purpose and exports declared below without altering runtime semantics.
Key exports: review the functions, classes, and constants defined in this file when tracing dependencies across the codebase.
Documentation onlyâ€”do not change runtime behavior when updating this note.
"""

from __future__ import annotations

import json
import logging
import smtplib
from collections.abc import Iterable
from email.message import EmailMessage
from typing import Any, Literal, TypedDict

from atticus.config import load_settings
from atticus.logging import configure_logging, log_error


class EscalationDeliveryError(RuntimeError):
    """Raised when an escalation email cannot be delivered."""

    def __init__(self, message: str, *, reason: str = "unknown") -> None:
        super().__init__(message)
        self.reason = reason


class _DryRunResult(TypedDict):
    status: Literal["dry-run"]
    host: str
    port: int


def _normalise_allow_list(values: Iterable[str]) -> list[str]:
    result: list[str] = []
    for value in values:
        if not value:
            continue
        cleaned = value.strip().lower()
        if cleaned:
            result.append(cleaned)
    return result


def _address_allowed(address: str, allow_list: Iterable[str]) -> bool:
    normalised = _normalise_allow_list(allow_list)
    if not normalised:
        return True
    candidate = address.strip().lower()
    if candidate in normalised:
        return True
    if "@" in candidate:
        _, _, domain = candidate.partition("@")
        patterns = {domain, f"@{domain}", f"*@{domain}"}
        if any(pattern in normalised for pattern in patterns):
            return True
    return False


def _compose_message(
    subject: str,
    body: str,
    sender: str,
    recipient: str,
    trace: dict[str, Any] | None = None,
) -> EmailMessage:
    msg = EmailMessage()
    msg["Subject"] = subject
    msg["From"] = sender
    msg["To"] = recipient
    if trace:
        trace_dump = json.dumps(trace, indent=2, ensure_ascii=False)
        body = f"{body}\n\nTrace Payload\n--------------\n{trace_dump}"
    msg.set_content(body)
    return msg


def _log_failure(
    logger: logging.Logger, *, reason: str, host: str, port: int, exc: Exception
) -> None:
    log_error(
        logger,
        "escalation_email_failed",
        reason=reason,
        host=host,
        port=port,
        error=str(exc),
    )


def _summarize_trace(trace: dict[str, Any] | None) -> dict[str, Any] | None:
    if not trace:
        return None
    summary: dict[str, Any] = {}
    for key in ("user_id", "chat_id", "message_id", "request_id"):
        if trace.get(key):
            summary[key] = trace[key]
    question = trace.get("question")
    if isinstance(question, str) and question.strip():
        summary["question_preview"] = question.strip()[:120]
    documents = trace.get("documents") or trace.get("top_documents")
    if isinstance(documents, list) and documents:
        summary["documents"] = [
            {
                "chunk_id": item.get("chunk_id"),
                "score": item.get("score"),
                "source_path": item.get("source_path"),
            }
            for item in documents[:5]
            if isinstance(item, dict)
        ]
    return summary or None


def send_escalation(
    subject: str,
    body: str,
    to: str | None = None,
    *,
    trace: dict[str, Any] | None = None,
) -> _DryRunResult | None:
    """Send an escalation email via SMTP.

    Recipient resolution order: explicit `to` -> `SMTP_TO` -> `CONTACT_EMAIL`.
    Returns dry-run metadata when SMTP_DRY_RUN is enabled; otherwise None.
    """
    settings = load_settings()
    logger = configure_logging(settings)

    candidates = [
        (to or "").strip(),
        (settings.smtp_to or "").strip(),
        (settings.contact_email or "").strip(),
    ]
    allow_list = settings.smtp_allow_list
    recipient: str | None = None
    for candidate in candidates:
        if not candidate:
            continue
        if allow_list and not _address_allowed(candidate, allow_list):
            continue
        recipient = candidate
        break

    if recipient is None:
        if allow_list:
            raise EscalationDeliveryError(
                "Recipient not approved for escalation email.",
                reason="recipient_not_allowed",
            )
        logger.warning("No recipient configured for escalation email; skipping send")
        return None

    host = (settings.smtp_host or "").strip()
    if not host:
        logger.warning("SMTP_HOST not configured; skipping send")
        return None

    port = int(settings.smtp_port or 587)
    sender = settings.smtp_from or settings.smtp_user or f"no-reply@{host}"

    if not _address_allowed(recipient, allow_list):
        raise EscalationDeliveryError(
            "Recipient not approved for escalation email.",
            reason="recipient_not_allowed",
        )
    if sender and not _address_allowed(sender, allow_list):
        raise EscalationDeliveryError(
            "SMTP_FROM address not present in allow list.",
            reason="sender_not_allowed",
        )

    msg = _compose_message(
        subject=subject,
        body=body,
        sender=sender,
        recipient=recipient,
        trace=trace,
    )

    trace_summary = _summarize_trace(trace)

    if settings.smtp_dry_run:
        logger.info(
            "escalation_email_dry_run",
            extra={
                "extra_payload": {
                    "to": "(redacted)",
                    "host": host,
                    "port": port,
                    "trace": trace_summary,
                }
            },
        )
        return {"status": "dry-run", "host": host, "port": int(port)}

    try:
        with smtplib.SMTP(host, port, timeout=20) as client:
            client.ehlo()
            try:
                client.starttls()
            except smtplib.SMTPNotSupportedError as exc:  # pragma: no cover - legacy SMTP
                _log_failure(logger, reason="tls_not_supported", host=host, port=port, exc=exc)
                raise EscalationDeliveryError(
                    "SMTP server does not support STARTTLS; escalation email not sent.",
                    reason="tls_not_supported",
                ) from exc

            if settings.smtp_user and settings.smtp_pass:
                client.login(settings.smtp_user, settings.smtp_pass)

            try:
                client.send_message(msg)
            except AttributeError:
                client.sendmail(sender, [recipient], msg.as_string())

            logger.info(
                "escalation_email_sent",
                extra={
                    "extra_payload": {
                        "to": "(redacted)",
                        "host": host,
                        "port": port,
                        "trace": trace_summary,
                    }
                },
            )
    except smtplib.SMTPAuthenticationError as exc:
        _log_failure(logger, reason="authentication_failed", host=host, port=port, exc=exc)
        raise EscalationDeliveryError(
            "SMTP authentication failed while sending escalation email.",
            reason="authentication_failed",
        ) from exc
    except (smtplib.SMTPConnectError, OSError) as exc:
        _log_failure(logger, reason="connection_error", host=host, port=port, exc=exc)
        raise EscalationDeliveryError(
            "Unable to connect to the SMTP server for escalation email.",
            reason="connection_error",
        ) from exc
    except smtplib.SMTPException as exc:
        _log_failure(logger, reason="smtp_error", host=host, port=port, exc=exc)
        raise EscalationDeliveryError(
            "Unexpected SMTP error while sending escalation email.",
            reason="smtp_error",
        ) from exc

    return None
