/**
 * Autogenerated documentation for `prisma/seed.ts` within the Atticus codebase.
 * Key exports: follow the named or default exports defined below; inputs and outputs remain as implemented and correlate with related modules via existing imports.
 * Documentation only—do not modify runtime behavior when updating this comment.
 */

import { GlossaryStatus, Prisma, PrismaClient, Role } from "@prisma/client";

const prisma = new PrismaClient();

type SeedUser = {
  id: string;
  email: string;
  name: string;
  role: Role;
};

type GlossarySeed = {
  id: string;
  term: string;
  definition: string;
  synonyms: string[];
  status: GlossaryStatus;
  reviewNotes?: string;
  reviewerId?: string;
  reviewedAt?: Date;
};

type ChatSeed = {
  id: string;
  question: string;
  answer?: string;
  confidence: number;
  status: string;
  requestId?: string;
  topSources: Array<{
    path: string;
    score?: number;
    page?: number;
    heading?: string;
    chunkId?: string;
  }>;
  followUpPrompt?: string;
  auditLog?: Array<Record<string, unknown>>;
  createdAt: Date;
  userId?: string;
  reviewedById?: string | null;
  reviewedAt?: Date | null;
  tickets?: TicketSeed[];
};

type TicketSeed = {
  id: string;
  key: string;
  status: string;
  assignee?: string;
  lastActivity?: Date;
  summary?: string;
  auditLog?: Array<Record<string, unknown>>;
};

const seedUsers: SeedUser[] = [
  {
    id: "user-seed-author",
    email: "glossary.author@seed.atticus",
    name: "Glossary Seed Author",
    role: Role.REVIEWER,
  },
  {
    id: "user-seed-approver",
    email: "glossary.approver@seed.atticus",
    name: "Glossary Seed Approver",
    role: Role.ADMIN,
  },
];

async function main() {
  const defaultOrgId = process.env.DEFAULT_ORG_ID ?? "org-atticus";
  const defaultOrgName = process.env.DEFAULT_ORG_NAME ?? "Atticus Default";
  const adminEmail = process.env.ADMIN_EMAIL;
  const adminName = process.env.ADMIN_NAME ?? "Atticus Admin";

  const organization = await prisma.organization.upsert({
    where: { id: defaultOrgId },
    update: { name: defaultOrgName },
    create: {
      id: defaultOrgId,
      name: defaultOrgName,
    },
  });

  if (adminEmail) {
    await prisma.user.upsert({
      where: { email: adminEmail.toLowerCase() },
      update: {
        role: Role.ADMIN,
        orgId: organization.id,
      },
      create: {
        email: adminEmail.toLowerCase(),
        name: adminName,
        role: Role.ADMIN,
        orgId: organization.id,
      },
    });
  }

  const seededUsers = await Promise.all(
    seedUsers.map((user) =>
      prisma.user.upsert({
        where: { id: user.id },
        update: {
          email: user.email,
          name: user.name,
          role: user.role,
          orgId: organization.id,
        },
        create: {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
          orgId: organization.id,
        },
      })
    )
  );

  const author = seededUsers.find((user) => user.id === "user-seed-author");
  const approver = seededUsers.find((user) => user.id === "user-seed-approver");

  if (!author || !approver) {
    throw new Error("Failed to seed glossary users");
  }

  const glossarySeeds: GlossarySeed[] = [
    {
      id: "glossary-entry-managed-print-services",
      term: "Managed Print Services",
      definition:
        "End-to-end management of printers, consumables, maintenance, and support delivered as a subscription.",
      synonyms: ["MPS", "Print-as-a-service"],
      status: GlossaryStatus.APPROVED,
      reviewNotes: "Approved for launch collateral and onboarding playbooks.",
      reviewerId: approver.id,
      reviewedAt: new Date("2024-05-01T12:00:00Z"),
    },
    {
      id: "glossary-entry-proactive-maintenance",
      term: "Proactive Maintenance",
      definition:
        "Scheduled device inspections and firmware rollouts designed to prevent outages before they impact revenue teams.",
      synonyms: ["Preventative maintenance"],
      status: GlossaryStatus.PENDING,
    },
    {
      id: "glossary-entry-toner-optimization",
      term: "Toner Optimization",
      definition:
        "Adaptive print routing and toner yield tracking that reduce waste while maintaining SLA-compliant image quality.",
      synonyms: ["Smart toner", "Consumable optimisation"],
      status: GlossaryStatus.REJECTED,
      reviewNotes: "Rejected pending customer-ready evidence and usage data.",
      reviewerId: approver.id,
      reviewedAt: new Date("2024-05-15T09:30:00Z"),
    },
  ];

  await Promise.all(
    glossarySeeds.map((entry) =>
      prisma.glossaryEntry.upsert({
        where: { id: entry.id },
        update: {
          term: entry.term,
          definition: entry.definition,
          synonyms: entry.synonyms,
          status: entry.status,
          orgId: organization.id,
          authorId: author.id,
          reviewerId: entry.reviewerId ?? null,
          reviewNotes: entry.reviewNotes ?? null,
          reviewedAt: entry.reviewedAt ?? null,
        },
        create: {
          id: entry.id,
          term: entry.term,
          definition: entry.definition,
          synonyms: entry.synonyms,
          status: entry.status,
          orgId: organization.id,
          authorId: author.id,
          reviewerId: entry.reviewerId ?? null,
          reviewNotes: entry.reviewNotes ?? null,
          reviewedAt: entry.reviewedAt ?? null,
        },
      })
    )
  );

  const chatSeeds: ChatSeed[] = [
    {
      id: "chat-low-confidence-toner",
      question: "Why are toner replacement alerts firing for the West team despite new cartridges?",
      confidence: 0.38,
      status: "pending_review",
      requestId: "req-seed-001",
      topSources: [
        {
          path: "content/operations/toner-optimization.md#alerts",
          score: 0.82,
          heading: "Alert tuning guidance",
          chunkId: "chunk-toner-alerts",
        },
        {
          path: "content/playbooks/ced-toner-guide.pdf",
          score: 0.74,
          page: 3,
          heading: "Replace cartridges sequence",
          chunkId: "chunk-toner-guide-3",
        },
      ],
      createdAt: new Date("2024-07-08T10:15:00Z"),
      auditLog: [
        {
          action: "captured",
          at: "2024-07-08T10:15:10.000Z",
          confidence: 0.38,
        },
        {
          action: "followup",
          at: "2024-07-08T10:17:00.000Z",
          prompt: "Confirm the affected device serial numbers and share recent firmware updates.",
        },
      ],
      userId: author.id,
      followUpPrompt: "Confirm serial numbers and firmware applied last week.",
    },
    {
      id: "chat-escalated-calibration",
      question: "Color calibration fails with streak artifacts on the ProLine 5100 series. What should we try next?",
      confidence: 0.41,
      status: "escalated",
      requestId: "req-seed-002",
      topSources: [
        {
          path: "content/troubleshooting/calibration-checklist.md#step-4",
          score: 0.68,
          heading: "Step 4 — Inspect rollers",
          chunkId: "chunk-calibration-4",
        },
        {
          path: "content/faq/pressroom-maintenance.md#color",
          score: 0.62,
          heading: "Color drift playbook",
          chunkId: "chunk-maintenance-color",
        },
      ],
      createdAt: new Date("2024-06-18T14:45:00Z"),
      auditLog: [
        {
          action: "escalate",
          at: "2024-06-18T15:00:00.000Z",
          actorId: approver.id,
          actorRole: Role.ADMIN,
          summary: "Calibration streaks observed in pilot deployment.",
        },
      ],
      userId: author.id,
      tickets: [
        {
          id: "ticket-ae-1001",
          key: "AE-1001",
          status: "open",
          assignee: "AEX-ops",
          lastActivity: new Date("2024-06-18T15:00:00Z"),
          summary: "Investigate streak artifacts for ProLine 5100 pilot.",
          auditLog: [
            {
              action: "created",
              at: "2024-06-18T15:00:00.000Z",
              actorId: approver.id,
              actorRole: Role.ADMIN,
            },
          ],
        },
      ],
    },
  ];

  for (const chatSeed of chatSeeds) {
    const chat = await prisma.chat.upsert({
      where: { id: chatSeed.id },
      update: {
        question: chatSeed.question,
        answer: chatSeed.answer ?? null,
        confidence: chatSeed.confidence,
        status: chatSeed.status,
        requestId: chatSeed.requestId ?? null,
        topSources: chatSeed.topSources as Prisma.InputJsonValue,
        auditLog: (chatSeed.auditLog ?? []) as Prisma.InputJsonValue,
        userId: chatSeed.userId ?? author.id,
        reviewedById: chatSeed.reviewedById ?? null,
        reviewedAt: chatSeed.reviewedAt ?? null,
        followUpPrompt: chatSeed.followUpPrompt ?? null,
      },
      create: {
        id: chatSeed.id,
        orgId: organization.id,
        userId: chatSeed.userId ?? author.id,
        question: chatSeed.question,
        answer: chatSeed.answer ?? null,
        confidence: chatSeed.confidence,
        status: chatSeed.status,
        requestId: chatSeed.requestId ?? null,
        topSources: chatSeed.topSources as Prisma.InputJsonValue,
        auditLog: (chatSeed.auditLog ?? []) as Prisma.InputJsonValue,
        createdAt: chatSeed.createdAt,
        reviewedById: chatSeed.reviewedById ?? null,
        reviewedAt: chatSeed.reviewedAt ?? null,
        followUpPrompt: chatSeed.followUpPrompt ?? null,
      },
    });

    await prisma.ragEvent.upsert({
      where: { id: `${chatSeed.id}-captured` },
      update: {
        orgId: organization.id,
        actorId: chatSeed.userId ?? author.id,
        actorRole: Role.USER,
        action: "chat.captured",
        entity: "chat",
        chatId: chat.id,
        requestId: chatSeed.requestId ?? null,
        after: {
          status: chatSeed.status,
          confidence: chatSeed.confidence,
        },
      },
      create: {
        id: `${chatSeed.id}-captured`,
        orgId: organization.id,
        actorId: chatSeed.userId ?? author.id,
        actorRole: Role.USER,
        action: "chat.captured",
        entity: "chat",
        chatId: chat.id,
        requestId: chatSeed.requestId ?? null,
        after: {
          status: chatSeed.status,
          confidence: chatSeed.confidence,
        },
      },
    });

    if (chatSeed.followUpPrompt) {
      await prisma.ragEvent.upsert({
        where: { id: `${chatSeed.id}-followup` },
        update: {
          orgId: organization.id,
          actorId: approver.id,
          actorRole: Role.ADMIN,
          action: "chat.followup_recorded",
          entity: "chat",
          chatId: chat.id,
          requestId: chatSeed.requestId ?? null,
          after: {
            followUpPrompt: chatSeed.followUpPrompt,
          },
        },
        create: {
          id: `${chatSeed.id}-followup`,
          orgId: organization.id,
          actorId: approver.id,
          actorRole: Role.ADMIN,
          action: "chat.followup_recorded",
          entity: "chat",
          chatId: chat.id,
          requestId: chatSeed.requestId ?? null,
          after: {
            followUpPrompt: chatSeed.followUpPrompt,
          },
        },
      });
    }

    if (chatSeed.tickets?.length) {
      for (const ticket of chatSeed.tickets) {
        await prisma.ticket.upsert({
          where: { id: ticket.id },
          update: {
            key: ticket.key,
            status: ticket.status,
            assignee: ticket.assignee ?? null,
            lastActivity: ticket.lastActivity ?? null,
            summary: ticket.summary ?? null,
            auditLog: (ticket.auditLog ?? []) as Prisma.InputJsonValue,
            chatId: chat.id,
            orgId: organization.id,
          },
          create: {
            id: ticket.id,
            key: ticket.key,
            status: ticket.status,
            assignee: ticket.assignee ?? null,
            lastActivity: ticket.lastActivity ?? null,
            summary: ticket.summary ?? null,
            auditLog: (ticket.auditLog ?? []) as Prisma.InputJsonValue,
            chatId: chat.id,
            orgId: organization.id,
          },
        });
      }

      await prisma.ragEvent.upsert({
        where: { id: `${chatSeed.id}-escalated` },
        update: {
          orgId: organization.id,
          actorId: approver.id,
          actorRole: Role.ADMIN,
          action: "chat.escalated",
          entity: "chat",
          chatId: chat.id,
          requestId: chatSeed.requestId ?? null,
          after: {
            status: "escalated",
            ticket: chatSeed.tickets.at(0)?.key ?? null,
          },
        },
        create: {
          id: `${chatSeed.id}-escalated`,
          orgId: organization.id,
          actorId: approver.id,
          actorRole: Role.ADMIN,
          action: "chat.escalated",
          entity: "chat",
          chatId: chat.id,
          requestId: chatSeed.requestId ?? null,
          after: {
            status: "escalated",
            ticket: chatSeed.tickets.at(0)?.key ?? null,
          },
        },
      });
    }
  }
}

main()
  .then(async () => {
    await prisma.$disconnect();
  })
  .catch(async (error) => {
    console.error("Seeding failed", error);
    await prisma.$disconnect();
    process.exit(1);
  });
