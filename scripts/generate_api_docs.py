"""Autogenerated documentation for `scripts/generate_api_docs.py` within the Atticus project.

This module participates in the documentation pipeline by summarizing the purpose and exports declared below without altering runtime semantics.
Key exports: review the functions, classes, and constants defined in this file when tracing dependencies across the codebase.
Documentation onlyâ€”do not change runtime behavior when updating this note.
"""

from __future__ import annotations

import argparse
import inspect
import json
import sys
from pathlib import Path
from typing import Any, get_type_hints

import yaml

ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

from api.main import app  # noqa: E402


# --- Pydantic v2 forward-ref rebuild shim (autogenerated) ---
try:
    from pydantic import BaseModel

    def __rebuild_pydantic_models() -> None:
        visited: set[type[BaseModel]] = set()

        def _recurse(cls: type[BaseModel]) -> None:
            if cls in visited:
                return
            visited.add(cls)
            try:
                rebuild = getattr(cls, "model_rebuild", None)
                if callable(rebuild):
                    try:
                        rebuild(_recursive_=True)
                    except TypeError:
                        rebuild(recursive=True)
            except Exception:
                pass
            for sub in getattr(cls, "__subclasses__", lambda: [])():
                _recurse(sub)

        for root in list(BaseModel.__subclasses__()):
            _recurse(root)

    __rebuild_pydantic_models()
except Exception:
    # Non-fatal: generator should still run
    pass
# ------------------------------------------------------------



FAILED_HINTS: list[str] = []


def __resolve_forward_refs() -> None:
    """Best-effort resolution for postponed annotations under Pydantic v2."""

    processed: dict[object, str] = {}

    def _update_annotations(callable_obj: Any) -> None:
        if callable_obj is None:
            return
        target = getattr(callable_obj, "__wrapped__", callable_obj)
        if target in processed:
            return
        if not (inspect.isfunction(target) or inspect.ismethod(target)):
            return
        processed[target] = getattr(target, "__qualname__", repr(target))

        module = sys.modules.get(getattr(target, "__module__", ""), None)
        namespace: dict[str, Any] = getattr(module, "__dict__", {}) if module else {}

        try:
            evaluated = get_type_hints(
                target, globalns=namespace, localns=namespace, include_extras=True
            )
        except TypeError:
            try:
                evaluated = get_type_hints(target, globalns=namespace, localns=namespace)
            except Exception as exc:
                FAILED_HINTS.append(f"{target.__module__}.{getattr(target, '__qualname__', repr(target))}: {exc}")
                return
        except Exception as exc:
            FAILED_HINTS.append(f"{target.__module__}.{getattr(target, '__qualname__', repr(target))}: {exc}")
            return

        annotations = getattr(target, "__annotations__", None)
        if isinstance(annotations, dict):
            annotations.update(evaluated)

    def _walk_dependant(dependant: Any) -> None:
        if dependant is None:
            return
        _update_annotations(getattr(dependant, "call", None))
        for child in getattr(dependant, "dependencies", []) or []:
            _walk_dependant(child)

    for route in getattr(app, "routes", []):
        _update_annotations(getattr(route, "endpoint", None))
        dependant = getattr(route, "dependant", None)
        _walk_dependant(dependant)

    for route in getattr(app, "routes", []):
        try:
            route.dependant = route.get_dependant()
            route.body_field = route.get_body_field()
        except AttributeError:
            continue


__resolve_forward_refs()

if FAILED_HINTS:
    debug_log = ROOT / "reports" / "openapi-typehint-failures.txt"
    debug_log.parent.mkdir(parents=True, exist_ok=True)
    debug_log.write_text("\n".join(FAILED_HINTS) + "\n", encoding="utf-8")


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Generate API documentation artifacts")
    parser.add_argument(
        "--output",
        type=Path,
        default=ROOT / "docs" / "api" / "openapi.json",
        help="Path to write the OpenAPI document (defaults to docs/api/openapi.json)",
    )
    parser.add_argument(
        "--format",
        choices=("json", "yaml"),
        default="json",
        help="Output format for the schema",
    )
    parser.add_argument(
        "--indent",
        type=int,
        default=2,
        help="Indentation for JSON output",
    )
    return parser


def export_schema(output_path: Path, output_format: str, indent: int = 2) -> None:
    schema = app.openapi()
    output_path.parent.mkdir(parents=True, exist_ok=True)

    if output_format == "json":
        payload = json.dumps(schema, indent=indent, sort_keys=True)
        output_path.write_text(payload + "\n", encoding="utf-8")
    else:
        payload = yaml.safe_dump(schema, sort_keys=False)
        output_path.write_text(payload, encoding="utf-8")


def main() -> None:
    parser = build_parser()
    args = parser.parse_args()
    export_schema(output_path=args.output, output_format=args.format, indent=args.indent)


if __name__ == "__main__":
    main()

